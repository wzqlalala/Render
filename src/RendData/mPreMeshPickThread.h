#pragma once
//解决中文乱码
#pragma execution_character_set("utf-8")

#include "renddata_global.h"

#include <QObject>
#include <QMatrix4x4>
#include <QVector>
#include <QVector2D>
#include <QThread>
#include <set>

#include "SpaceTree.h"

#include "mMeshViewEnum.h"

#include <memory>


using namespace MViewBasic;
using namespace Space;
using namespace std;
namespace MDataMesh
{
	class mPreMeshPickData1;
	class mMeshModelData;
	class mMeshPartData;
	class mMeshData;
	class mMeshFaceData;
	class mMeshNodeData;
	class mMeshLineData;
	class mBasePick
	{
	public:

		mBasePick(QMatrix4x4 pvm, int w, int h) { _pvm = pvm; _width = w; _height = h; };

		virtual bool getPickIsIntersectionWithAABB(Space::AABB aabb) = 0;

		virtual bool get2DAnd3DMeshCenterIsInPick(QVector3D pointCenter) = 0;//0维和2维和3维

		virtual bool get1DMeshIsInPick(QVector<QVector3D> vertexs) = 0;//1维

		virtual bool isIntersectionAABBAndPick(QVector<QVector2D> ap) = 0;//判断是否相交

		virtual bool isAABBPointIsAllInPick(QVector<QVector2D> ap) = 0;//判断点是否全部

		//将Space::AABB的八个顶点转化为二维屏幕的点
		QVector<QVector2D> getAABBToScreenVertex(QVector3D minEdge, QVector3D maxEdge);
		//将屏幕坐标转化为世界坐标
		QVector3D ScreenvertexToWorldvertex(QVector3D vertex);
		//将世界坐标转化为屏幕坐标
		QVector2D WorldvertexToScreenvertex(QVector3D Worldvertex);
		QVector<QVector2D> WorldvertexToScreenvertex(QVector<QVector3D> Worldvertexs);
		//将世界坐标转化为屏幕坐标并且返回他的深度值
		QVector2D WorldvertexToScreenvertex(QVector3D Worldvertex, float &depth);
		void WorldvertexToScreenvertex(QVector<QVector3D> Worldvertexs, QVector<QVector2D> &Screenvertexs, std::set<float> &depths);

	protected:
		QMatrix4x4 _pvm;
		int _width, _height;
		MViewBasic::MultiplyPickMode _multiplyPickMode;

	};


	class mQuadPick :public mBasePick
	{
	public:
		mQuadPick(QMatrix4x4 pvm, int w, int h, QVector<QVector2D> multiQuad) :mBasePick(pvm, w, h), _multiQuad(multiQuad)
		{
			_center = (_multiQuad.first() + _multiQuad.last()) / 2.0;
			_boxXY_2 = _multiQuad.first() - _center; _boxXY_2[0] = qAbs(_boxXY_2[0]); _boxXY_2[1] = qAbs(_boxXY_2[1]);
			_multiQuad = QVector<QVector2D>{ multiQuad.first(),QVector2D(multiQuad.first().x(), multiQuad.last().y()),multiQuad.last(),  QVector2D(multiQuad.last().x(), multiQuad.first().y()) };
		};

		bool getPickIsIntersectionWithAABB(Space::AABB aabb) override;

		bool get2DAnd3DMeshCenterIsInPick(QVector3D pointCenter) override;//0维和2维和3维

		bool get1DMeshIsInPick(QVector<QVector3D> vertexs) override;//1维

		bool isIntersectionAABBAndPick(QVector<QVector2D> ap) override;

		bool isAABBPointIsAllInPick(QVector<QVector2D> ap) override;//判断点是否全部

	protected:
		QVector<QVector2D> _multiQuad;

		QVector2D _center, _boxXY_2;

	};

	class mPolygonPick :public mBasePick
	{
	public:
		mPolygonPick(QMatrix4x4 pvm, int w, int h, QVector<QVector2D> multiQuad) :mBasePick(pvm, w, h), _multiQuad(multiQuad)
		{
			_center = (_multiQuad.first() + _multiQuad.last()) / 2.0;
		};

		bool getPickIsIntersectionWithAABB(Space::AABB aabb) override;

		bool get2DAnd3DMeshCenterIsInPick(QVector3D pointCenter) override;//0维和2维和3维

		bool get1DMeshIsInPick(QVector<QVector3D> vertexs) override;//1维

		bool isIntersectionAABBAndPick(QVector<QVector2D> ap) override;

		bool isAABBPointIsAllInPick(QVector<QVector2D> ap) override;//判断点是否全部

	protected:
		QVector<QVector2D> _multiQuad;

		QVector2D _center;

	};

	class mRoundPick :public mBasePick
	{
	public:
		mRoundPick(QMatrix4x4 pvm, int w, int h, QVector2D p1, QVector2D p2, QVector3D centerDirection)
			:mBasePick(pvm, w, h)
		{
			_screenCenter = (p1 + p2) / 2.0;
			QVector3D Point = ScreenvertexToWorldvertex(p2);//算出圆上一点的坐标
			_centerPoint = ScreenvertexToWorldvertex(_screenCenter);//算出圆心坐标
			_radius = _centerPoint.distanceToPoint(Point);
			_screenRadius = _screenCenter.distanceToPoint(p1);
			_centerDirection = centerDirection;
		};

		bool getPickIsIntersectionWithAABB(Space::AABB aabb) override;

		bool get2DAnd3DMeshCenterIsInPick(QVector3D pointCenter) override;//0维和2维和3维

		bool get1DMeshIsInPick(QVector<QVector3D> vertexs) override;//1维

		bool isIntersectionAABBAndPick(QVector<QVector2D> ap) override;

		bool isAABBPointIsAllInPick(QVector<QVector2D> ap) override;//判断点是否全部

	protected:
		QVector3D _centerPoint; QVector3D _centerDirection; double _radius; //空间
		QVector2D _screenCenter; double _screenRadius;//屏幕
	};
	class RENDDATA_EXPORT mPreMeshPickThread : public QObject
	{
		Q_OBJECT

	public:
		/*
		* 复制构造函数
		*/
		mPreMeshPickThread(mPreMeshPickData1 *pickData);

		/*
		* 析构函数
		*/
		~mPreMeshPickThread();

		/*
		* 设置当前的拾取模式
		*/
		void setPickMode(PickMode pickMode, MultiplyPickMode multiplyPickMode);

		/*
		* 设置当前的拾取过滤器
		*/
		void setPickFilter(PickFilter *pickFilter);

		/*
		 * 开始拾取
		 */
		void startPick();

		/*
		 * 设置矩阵
		 */
		void setMatrix(QMatrix4x4 projection, QMatrix4x4 view, QMatrix4x4 model);

		/*
		* 设置矩阵
		*/
		void setMatrix(QMatrix4x4 pvm);

		/*
		* 设置通过角度拾取的角度
		*/
		void setPickAngleValue(double angle) { _pickAngleValue = angle; };

		/*
		* 设置网格数据
		*/
		void setMeshModelData(std::shared_ptr<mMeshModelData> meshModelData);

		/*
		 * 设置单选位置
		 */
		void setLocation(const QVector2D & pos, float depth);

		/*
		* 设置位置(矩形或者多边形框选)
		*/
		void setLocation(QVector<QVector2D> pickQuad, QVector3D direction = QVector3D());

		/*
		 * 设置窗口大小
		 */
		void setWidget(int w, int h);

		/*
		 *	是否完成拾取
		 */
		bool isFinished();

		/*
		 * 拾取完成设置为false
		 */
		void setFinished();
	private:
		//拾取主程序		
		void doSoloPick(QString partName);
		void doMultiplyPick(QString partName);
		void doAnglePick();

		/*
		 * 单选
		 */
		//void SoloPickAny(QString partName);
		//void SoloPickPoint(QString partName);
		//void SoloPick1DMesh(QString partName);
		//void SoloPick2DMesh(QString partName);
		//void SoloPickTri(QString partName);
		//void SoloPickQuad(QString partName);
		//void SoloPickTet(QString partName);
		//void SoloPickPyramid(QString partName);
		//void SoloPickWedge(QString partName);
		//void SoloPickHex(QString partName);
		void SoloPickMeshTypeFilter(std::shared_ptr<mMeshPartData> partData, QVector<MeshType> filters);
		void SoloPickNode(std::shared_ptr<mMeshPartData> partData);
		void SoloPickAnyMesh(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshLine(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshFace(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshPart(std::shared_ptr<mMeshPartData> partData);
		void SoloPickNodeByPart(std::shared_ptr<mMeshPartData> partData);
		void SoloPickAnyMeshByPart(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshLineByPart(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshFaceByPart(std::shared_ptr<mMeshPartData> partData);
		void SoloPickNodeByLine(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshByLine(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshLineByLine(std::shared_ptr<mMeshPartData> partData);
		void SoloPickNodeByFace(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshByFace(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshFaceByFace(std::shared_ptr<mMeshPartData> partData);
		void SoloPickNodeByLineAngle(std::shared_ptr<mMeshPartData> partData);
		void SoloPickNodeByFaceAngle(std::shared_ptr<mMeshPartData> partData);
		void SoloPick1DMeshByAngle(std::shared_ptr<mMeshPartData> partData);
		void SoloPick2DMeshByAngle(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshLineByAngle(std::shared_ptr<mMeshPartData> partData);
		void SoloPickMeshFaceByAngle(std::shared_ptr<mMeshPartData> partData);

		//框选拾取
		void MultiplyPickNode(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickAnyMesh(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickMeshTypeFilter(std::shared_ptr<mMeshPartData> partData, QVector<MeshType> filters, bool isAllIn = false);
		void MultiplyPickMeshLine(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickMeshFace(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickMeshPart(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickNodeByPart(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickAnyMeshByPart(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickMeshLineByPart(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickMeshFaceByPart(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickNodeByLine(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickMeshByLine(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickMeshLineByLine(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickNodeByFace(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickMeshByFace(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);
		void MultiplyPickMeshFaceByFace(std::shared_ptr<mMeshPartData> partData, bool isAllIn = false);

		void SoloPickNodePath();//通过路径拾取
		//通过角度拾取
		void SoloPickNodeByLineAngle();
		void SoloPickNodeByFaceAngle();
		void SoloPick1DMeshByAngle();
		void SoloPickMeshLineByAngle();
		void SoloPick2DMeshByAngle();
		void SoloPickMeshFaceByAngle();

		/*************单选***********/
		//判断单选是否拾取到部件

		//判断单选是否拾取到该部件
		bool isSoloPickMeshPart(std::shared_ptr<mMeshPartData> partData, float &depth);

		//判断单选是否拾取到该几何面
		//bool isSoloPickGeoFace(MXGeoFace* geoFaceData, float &depth);

		////判断单选是否拾取到该几何边
		//bool isSoloPickGeoLine(MXGeoEdge* geoEdgeData, float &depth);


		/***********框选*********/
		//判断是否拾取到该几何点
		//bool IsMultiplyPickGeoPoint(MXGeoPoint* geoPointData);

		//判断是否拾取到该几何线
		//bool IsMultiplyPickGeoLine(MXGeoEdge* geoLineData);

		////判断是否拾取到该几何面
		//bool IsMultiplyPickGeoFace(MXGeoFace* geoFaceData);

		//判断是否拾取到该几何体
		//bool IsMultiplyPickGeoSolid(MXGeoSolid* geoSolidData);

		//判断框选是否拾取到该部件
		bool isMultiplyPickMeshPart(std::shared_ptr<mMeshPartData> partData);


		//将世界坐标转化为屏幕坐标
		QVector2D WorldvertexToScreenvertex(QVector3D Worldvertex);

		QVector3D ScreenvertexToWorldvertex(QVector3D vertex);

		//将世界坐标转化为屏幕坐标并且返回他的深度值
		QVector2D WorldvertexToScreenvertex(QVector3D Worldvertex, float &depth);

		/*
		 * 将世界坐标转化为屏幕坐标并且返回他的深度值
		 */
		void WorldvertexToScreenvertex(QVector<QVector3D> Worldvertexs, QVector<QVector2D> &Screenvertexs, std::set<float> &depths);

		//获取形心
		QVector3D getCenter(QVector<QVector3D> vertexs);

		//获取一个部件的所有信息
		set<shared_ptr<mMeshNodeData>> getAllNodesByPartName(std::shared_ptr<mMeshPartData> partData);
		set<shared_ptr<mMeshData>> getAllMeshsByPartName(std::shared_ptr<mMeshPartData> partData);
		set<shared_ptr<mMeshFaceData>> getAllMeshFacesByPartName(std::shared_ptr<mMeshPartData> partData);
		set<shared_ptr<mMeshLineData>> getAllMeshLinesByPartName(std::shared_ptr<mMeshPartData> partData);
		//set<MXMeshVertex*> getAllNodesByGeoFace(MXGeoFace *entity);
		//set<MXMeshElement*> getAllMeshsByGeoFace(MXGeoFace *entity);
		//set<MFace*> getAllMeshFacesByGeoFace(MXGeoFace *entity);
		//set<MXMeshVertex*> getAllNodesByGeoEdge(MXGeoEdge *entity);
		//set<MXMeshElement*> getAllMeshsByGeoEdge(MXGeoEdge *entity);
		//set<MEdge*> getAllMeshLinesByGeoEdge(MXGeoEdge *entity);

	signals:
		/*
		 * 发送信号完成
		 */
		void finishedPickSig();


	public slots:


	private:

		//拾取过滤器
		PickFilter *_pickFilter;

		//拾取模式
		MViewBasic::PickMode _pickMode;

		//框选拾取模式
		MViewBasic::MultiplyPickMode _multiplyPickMode;

		//拾取角度
		float _pickAngleValue = 60;

		//窗口大小
		int _Win_WIDTH, _Win_HEIGHT;

		//着色器视图矩阵
		QMatrix4x4 _projection, _view, _model, _pvm;

		/*
		* 拾取数据
		*/
		mPreMeshPickData1 *_pickData;

		//模型数据
		std::shared_ptr<mMeshModelData> _meshModelData;

		/*
		 * 点选位置
		 */
		QVector2D _pos;
		float _depth;
		QVector3D _p;
		QVector3D _origin;
		QVector3D _dir;

		/*********/
		std::shared_ptr<mBasePick> _pick;
		/*
		 * 点选矩形
		 */
		QVector<QVector2D> soloQuad;

		/*
		 * 是否完成
		 */
		bool _isfinished;


	};
}
